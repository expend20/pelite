/*!
Tests for FH4 (FuncInfo4) exception handling structures.

Test data files (.exe) and expected values (.txt generated by Microsoft's DUMPBIN tool)
are automatically discovered from the `tests/exceptions/` directory.
Files are matched by their base name (e.g., `foo.exe` matches `foo.txt`).
*/

mod dumpbin_parser;

use dumpbin_parser::{parse_fh4_functions, ExpectedFh4};
use pelite::pe64::{Pe, PeFile};
use pelite::pe64::exception::{HandlerType};
use pelite::pe64::exception_fh4::{FuncInfo4, UnwindInfoFh4Ext};
use pelite::FileMap;
use std::fs;
use std::path::{Path, PathBuf};

const TEST_DIR: &str = "tests/exceptions";

/// Discovers all .exe/.txt file pairs in the test directory.
/// Returns a list of (exe_path, txt_path, base_name) tuples.
fn discover_test_files() -> Vec<(PathBuf, PathBuf, String)> {
    let test_dir = Path::new(TEST_DIR);
    let mut pairs = Vec::new();
    
    if let Ok(entries) = fs::read_dir(test_dir) {
        // Collect all .exe files
        let exe_files: Vec<PathBuf> = entries
            .filter_map(|e| e.ok())
            .map(|e| e.path())
            .filter(|p| p.extension().map_or(false, |ext| ext == "exe"))
            .collect();
        
        // For each .exe, check if matching .txt exists
        for exe_path in exe_files {
            let base_name = exe_path.file_stem()
                .and_then(|s| s.to_str())
                .map(|s| s.to_string());
            
            if let Some(base) = base_name {
                let txt_path = test_dir.join(format!("{}.txt", base));
                if txt_path.exists() {
                    pairs.push((exe_path, txt_path, base));
                }
            }
        }
    }
    
    pairs.sort_by(|a, b| a.2.cmp(&b.2)); // Sort by base name for consistent ordering
    pairs
}

//----------------------------------------------------------------
// Tests
//----------------------------------------------------------------

#[test]
fn fh4_basic_exception_table() {
    let test_files = discover_test_files();
    assert!(!test_files.is_empty(), "No test file pairs found in {}", TEST_DIR);
    
    for (exe_path, _txt_path, base_name) in &test_files {
        println!("Testing basic exception table for: {}", base_name);
        
        let file_map = FileMap::open(exe_path)
            .unwrap_or_else(|e| panic!("Failed to open {}: {:?}", exe_path.display(), e));
        let file = PeFile::from_bytes(&file_map)
            .unwrap_or_else(|e| panic!("Failed to parse PE {}: {:?}", exe_path.display(), e));
        let exception = file.exception()
            .unwrap_or_else(|e| panic!("Failed to get exception table for {}: {:?}", exe_path.display(), e));
        
        // Verify the table is sorted
        assert!(exception.check_sorted(), "Exception table should be sorted for {}", base_name);
        
        // Verify there are some functions
        let func_count = exception.functions().count();
        assert!(func_count > 0, "Expected at least some functions in exception table for {}", base_name);
        println!("  {} has {} functions in exception table", base_name, func_count);
    }
}

#[test]
fn fh4_parsing() {
    let test_files = discover_test_files();
    assert!(!test_files.is_empty(), "No test file pairs found in {}", TEST_DIR);
    
    let mut total_verified = 0;
    
    for (exe_path, txt_path, base_name) in &test_files {
        println!("Testing FH4 parsing for: {}", base_name);
        
        // Parse expected data from txt file
        let txt_content = fs::read_to_string(txt_path)
            .unwrap_or_else(|e| panic!("Failed to read {}: {:?}", txt_path.display(), e));
        let expected_functions = parse_fh4_functions(&txt_content);
        
        if expected_functions.is_empty() {
            println!("  No FH4 functions found in txt file, skipping");
            continue;
        }
        
        // Load the PE file
        let file_map = FileMap::open(exe_path)
            .unwrap_or_else(|e| panic!("Failed to open {}: {:?}", exe_path.display(), e));
        let file = PeFile::from_bytes(&file_map)
            .unwrap_or_else(|e| panic!("Failed to parse PE {}: {:?}", exe_path.display(), e));
        let exception = file.exception()
            .unwrap_or_else(|e| panic!("Failed to get exception table for {}: {:?}", exe_path.display(), e));
        
        // Track how many functions we've verified for this file
        let mut verified_count = 0;
        
        for expected in &expected_functions {
            // Find the function by begin address
            let func = exception
                .functions()
                .find(|f| f.image().BeginAddress == expected.begin_address)
                .unwrap_or_else(|| panic!("[{}] Function at 0x{:X} not found", base_name, expected.begin_address));
            
            let image = func.image();
            assert_eq!(
                image.BeginAddress, expected.begin_address,
                "[{}] BeginAddress mismatch for function at 0x{:X}",
                base_name, expected.begin_address
            );
            assert_eq!(
                image.EndAddress, expected.end_address,
                "[{}] EndAddress mismatch for function at 0x{:X}",
                base_name, expected.begin_address
            );
            
            // Get unwind info and parse FH4
            let unwind_info = func.unwind_info()
                .unwrap_or_else(|e| panic!("[{}] UnwindInfo failed for function at 0x{:X}: {:?}", base_name, expected.begin_address, e));
            
            // Verify handler_type() correctly identifies this as FH4
            let handler_type = unwind_info.handler_type(expected.begin_address, expected.end_address);
            assert_eq!(
                handler_type, HandlerType::Fh4,
                "[{}] handler_type() should return Fh4 for function at 0x{:X}, got {:?}",
                base_name, expected.begin_address, handler_type
            );
            
            let fh4 = unwind_info.func_info4()
                .unwrap_or_else(|e| panic!("[{}] FH4 parsing failed for function at 0x{:X}: {:?}", base_name, expected.begin_address, e));
            
            verify_fh4(&fh4, expected, base_name);
            verified_count += 1;
        }
        
        println!("  Verified {} FH4 functions in {}", verified_count, base_name);
        total_verified += verified_count;
    }
    
    println!("Total verified: {} FH4 functions across {} test files", total_verified, test_files.len());
    assert!(total_verified >= 5, "Should have verified at least 5 FH4 functions total");
}

fn verify_fh4(fh4: &FuncInfo4, expected: &ExpectedFh4, file_name: &str) {
    // Verify IP to State Map
    assert_eq!(
        fh4.ip_to_state_map.len(),
        expected.ip_to_state.len(),
        "[{}] IP to State Map count mismatch for function at 0x{:X}. Got {} expected {}",
        file_name, expected.begin_address,
        fh4.ip_to_state_map.len(),
        expected.ip_to_state.len()
    );
    
    for (i, (actual, (expected_ip, expected_state))) in fh4.ip_to_state_map.iter()
        .zip(&expected.ip_to_state).enumerate() 
    {
        assert_eq!(
            actual.ip_offset, *expected_ip,
            "[{}] IP offset mismatch at index {} for function at 0x{:X}. Got 0x{:X} expected 0x{:X}",
            file_name, i, expected.begin_address, actual.ip_offset, expected_ip
        );
        assert_eq!(
            actual.state, *expected_state,
            "[{}] State mismatch at index {} for function at 0x{:X}. Got {} expected {}",
            file_name, i, expected.begin_address, actual.state, expected_state
        );
    }
    
    // Verify Unwind Map
    assert_eq!(
        fh4.unwind_map.len(),
        expected.unwind_map.len(),
        "[{}] Unwind Map count mismatch for function at 0x{:X}. Got {} expected {}",
        file_name, expected.begin_address,
        fh4.unwind_map.len(),
        expected.unwind_map.len()
    );
    
    for (i, (actual, (_expected_next, expected_action))) in fh4.unwind_map.iter()
        .zip(&expected.unwind_map).enumerate() 
    {
        assert_eq!(
            actual.action_rva, *expected_action,
            "[{}] Action RVA mismatch at state {} for function at 0x{:X}. Got 0x{:X} expected 0x{:X}",
            file_name, i, expected.begin_address, actual.action_rva, expected_action
        );
    }
    
    // Verify Try Block Map
    assert_eq!(
        fh4.try_block_map.len(),
        expected.try_blocks.len(),
        "[{}] Try Block Map count mismatch for function at 0x{:X}. Got {} expected {}",
        file_name, expected.begin_address,
        fh4.try_block_map.len(),
        expected.try_blocks.len()
    );
    
    for (i, (actual, expected_try)) in fh4.try_block_map.iter()
        .zip(&expected.try_blocks).enumerate() 
    {
        assert_eq!(
            actual.try_low, expected_try.try_low,
            "[{}] try_low mismatch at try block {} for function at 0x{:X}",
            file_name, i, expected.begin_address
        );
        assert_eq!(
            actual.try_high, expected_try.try_high,
            "[{}] try_high mismatch at try block {} for function at 0x{:X}",
            file_name, i, expected.begin_address
        );
        assert_eq!(
            actual.catch_high, expected_try.catch_high,
            "[{}] catch_high mismatch at try block {} for function at 0x{:X}",
            file_name, i, expected.begin_address
        );
        
        // Verify handlers
        assert_eq!(
            actual.handlers.len(),
            expected_try.handlers.len(),
            "[{}] Handler count mismatch at try block {} for function at 0x{:X}",
            file_name, i, expected.begin_address
        );
        
        for (j, (actual_h, expected_h)) in actual.handlers.iter()
            .zip(&expected_try.handlers).enumerate() 
        {
            assert_eq!(
                actual_h.adjectives, expected_h.adjectives,
                "[{}] Handler adjectives mismatch at try block {}, handler {} for function at 0x{:X}. Got 0x{:X} expected 0x{:X}",
                file_name, i, j, expected.begin_address, actual_h.adjectives, expected_h.adjectives
            );
            assert_eq!(
                actual_h.type_desc_rva, expected_h.type_desc_rva,
                "[{}] Handler type_desc_rva mismatch at try block {}, handler {} for function at 0x{:X}. Got 0x{:X} expected 0x{:X}",
                file_name, i, j, expected.begin_address, actual_h.type_desc_rva, expected_h.type_desc_rva
            );
            assert_eq!(
                actual_h.catch_obj_offset, expected_h.catch_obj_offset,
                "[{}] Handler catch_obj_offset mismatch at try block {}, handler {} for function at 0x{:X}. Got 0x{:X} expected 0x{:X}",
                file_name, i, j, expected.begin_address, actual_h.catch_obj_offset, expected_h.catch_obj_offset
            );
            assert_eq!(
                actual_h.handler_rva, expected_h.handler_rva,
                "[{}] Handler handler_rva mismatch at try block {}, handler {} for function at 0x{:X}. Got 0x{:X} expected 0x{:X}",
                file_name, i, j, expected.begin_address, actual_h.handler_rva, expected_h.handler_rva
            );
        }
    }
}

#[test]
fn txt_parser_sanity_check() {
    let test_files = discover_test_files();
    assert!(!test_files.is_empty(), "No test file pairs found in {}", TEST_DIR);
    
    println!("Found {} test file pairs:", test_files.len());
    for (exe_path, txt_path, base_name) in &test_files {
        println!("  {} -> ({}, {})", base_name, exe_path.display(), txt_path.display());
    }
    
    // Verify the parser runs without errors on all txt files
    let mut total_fh4_functions = 0;
    for (_exe_path, txt_path, base_name) in &test_files {
        let txt_content = fs::read_to_string(txt_path)
            .unwrap_or_else(|e| panic!("Failed to read {}: {:?}", txt_path.display(), e));
        
        let functions = parse_fh4_functions(&txt_content);
        
        println!("\n{}: Parsed {} FH4 functions", base_name, functions.len());
        for f in &functions {
            println!("  0x{:04X}-0x{:04X}: {} ip_states, {} unwind_entries, {} try_blocks",
                f.begin_address, f.end_address,
                f.ip_to_state.len(), f.unwind_map.len(), f.try_blocks.len());
        }
        total_fh4_functions += functions.len();
    }
    
    // At least some test files should have FH4 functions
    assert!(total_fh4_functions > 0,
        "Expected at least some FH4 functions across all test files, got none");
}

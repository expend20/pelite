/*!
Tests for Unwind Codes parsing.

Test data files (.exe) and expected values (.txt generated by Microsoft's DUMPBIN tool)
are automatically discovered from the `tests/exceptions/` directory.
Files are matched by their base name (e.g., `foo.exe` matches `foo.txt`).

This test verifies that unwind codes are correctly decoded from the binary
and match the expected values from DUMPBIN output.
*/

mod dumpbin_parser;

use dumpbin_parser::{parse_unwind_info, ExpectedUnwindOp};
use pelite::pe64::{Pe, PeFile};
use pelite::pe64::exception::DecodedUnwindOp;
use pelite::pe64::exception_uc::DecodedUnwindCode;
use pelite::FileMap;
use std::fs;
use std::path::{Path, PathBuf};

const TEST_DIR: &str = "tests/exceptions";

/// Discovers all .exe/.txt file pairs in the test directory.
/// Returns a list of (exe_path, txt_path, base_name) tuples.
fn discover_test_files() -> Vec<(PathBuf, PathBuf, String)> {
    let test_dir = Path::new(TEST_DIR);
    let mut pairs = Vec::new();
    
    if let Ok(entries) = fs::read_dir(test_dir) {
        // Collect all .exe files
        let exe_files: Vec<PathBuf> = entries
            .filter_map(|e| e.ok())
            .map(|e| e.path())
            .filter(|p| p.extension().map_or(false, |ext| ext == "exe"))
            .collect();
        
        // For each .exe, check if matching .txt exists
        for exe_path in exe_files {
            let base_name = exe_path.file_stem()
                .and_then(|s| s.to_str())
                .map(|s| s.to_string());
            
            if let Some(base) = base_name {
                let txt_path = test_dir.join(format!("{}.txt", base));
                if txt_path.exists() {
                    pairs.push((exe_path, txt_path, base));
                }
            }
        }
    }
    
    pairs.sort_by(|a, b| a.2.cmp(&b.2)); // Sort by base name for consistent ordering
    pairs
}

//----------------------------------------------------------------
// Tests
//----------------------------------------------------------------

#[test]
fn unwind_codes_parsing() {
    let test_files = discover_test_files();
    assert!(!test_files.is_empty(), "No test file pairs found in {}", TEST_DIR);
    
    let mut total_verified = 0;
    
    for (exe_path, txt_path, base_name) in &test_files {
        println!("Testing unwind codes for: {}", base_name);
        
        // Parse expected unwind info from txt file
        let txt_content = fs::read_to_string(txt_path)
            .unwrap_or_else(|e| panic!("Failed to read {}: {:?}", txt_path.display(), e));
        let expected_unwind_info = parse_unwind_info(&txt_content);
        
        if expected_unwind_info.is_empty() {
            println!("  No unwind info found in txt file, skipping");
            continue;
        }
        
        // Load the PE file
        let file_map = FileMap::open(exe_path)
            .unwrap_or_else(|e| panic!("Failed to open {}: {:?}", exe_path.display(), e));
        let file = PeFile::from_bytes(&file_map)
            .unwrap_or_else(|e| panic!("Failed to parse PE {}: {:?}", exe_path.display(), e));
        let exception = file.exception()
            .unwrap_or_else(|e| panic!("Failed to get exception table for {}: {:?}", exe_path.display(), e));
        
        let mut verified_count = 0;
        
        for expected in &expected_unwind_info {
            // Find the function by begin address
            let func = match exception.functions().find(|f| f.image().BeginAddress == expected.begin_address) {
                Some(f) => f,
                None => continue, // Skip functions not in exception table
            };
            
            let unwind_info = match func.unwind_info() {
                Ok(info) => info,
                Err(_) => continue,
            };
            
            // Verify unwind info header
            assert_eq!(
                unwind_info.version(), expected.version,
                "[{}] Version mismatch for function at 0x{:X}",
                base_name, expected.begin_address
            );
            assert_eq!(
                unwind_info.flags(), expected.flags,
                "[{}] Flags mismatch for function at 0x{:X}. Got 0x{:X} expected 0x{:X}",
                base_name, expected.begin_address, unwind_info.flags(), expected.flags
            );
            assert_eq!(
                unwind_info.size_of_prolog() as u8, expected.size_of_prolog,
                "[{}] Size of prolog mismatch for function at 0x{:X}",
                base_name, expected.begin_address
            );
            
            // Verify decoded unwind codes
            let decoded_codes = unwind_info.decoded_unwind_codes();
            
            if !expected.unwind_codes.is_empty() {
                assert_eq!(
                    decoded_codes.len(), expected.unwind_codes.len(),
                    "[{}] Unwind code count mismatch for function at 0x{:X}. Got {} expected {}",
                    base_name, expected.begin_address, decoded_codes.len(), expected.unwind_codes.len()
                );
                
                for (i, (actual, expected_code)) in decoded_codes.iter().zip(&expected.unwind_codes).enumerate() {
                    assert_eq!(
                        actual.code_offset, expected_code.code_offset,
                        "[{}] Code offset mismatch at index {} for function at 0x{:X}",
                        base_name, i, expected.begin_address
                    );
                    
                    verify_unwind_op(&actual.operation, &expected_code.operation, base_name, expected.begin_address, i);
                }
            }
            
            verified_count += 1;
        }
        
        println!("  Verified {} functions with unwind codes in {}", verified_count, base_name);
        total_verified += verified_count;
    }
    
    println!("Total verified: {} functions with unwind codes across {} test files", total_verified, test_files.len());
    assert!(total_verified >= 1, "Should have verified at least 1 function with unwind codes");
}

fn verify_unwind_op(actual: &DecodedUnwindOp, expected: &ExpectedUnwindOp, file_name: &str, func_addr: u32, index: usize) {
    match (actual, expected) {
        (DecodedUnwindOp::PushNonVol { register }, ExpectedUnwindOp::PushNonVol { register: exp_reg }) => {
            let actual_name = DecodedUnwindCode::register_name(*register);
            assert_eq!(
                actual_name, exp_reg,
                "[{}] PUSH_NONVOL register mismatch at index {} for function at 0x{:X}",
                file_name, index, func_addr
            );
        }
        (DecodedUnwindOp::AllocLarge { size }, ExpectedUnwindOp::AllocLarge { size: exp_size }) => {
            assert_eq!(
                size, exp_size,
                "[{}] ALLOC_LARGE size mismatch at index {} for function at 0x{:X}",
                file_name, index, func_addr
            );
        }
        (DecodedUnwindOp::AllocSmall { size }, ExpectedUnwindOp::AllocSmall { size: exp_size }) => {
            assert_eq!(
                size, exp_size,
                "[{}] ALLOC_SMALL size mismatch at index {} for function at 0x{:X}",
                file_name, index, func_addr
            );
        }
        (DecodedUnwindOp::SetFpReg, ExpectedUnwindOp::SetFpReg) => {}
        (DecodedUnwindOp::SaveNonVol { register, offset }, ExpectedUnwindOp::SaveNonVol { register: exp_reg, offset: exp_offset }) => {
            let actual_name = DecodedUnwindCode::register_name(*register);
            assert_eq!(actual_name, exp_reg, "[{}] SAVE_NONVOL register mismatch at index {} for function at 0x{:X}", file_name, index, func_addr);
            assert_eq!(offset, exp_offset, "[{}] SAVE_NONVOL offset mismatch at index {} for function at 0x{:X}", file_name, index, func_addr);
        }
        (DecodedUnwindOp::SaveNonVolFar { register, offset }, ExpectedUnwindOp::SaveNonVolFar { register: exp_reg, offset: exp_offset }) => {
            let actual_name = DecodedUnwindCode::register_name(*register);
            assert_eq!(actual_name, exp_reg, "[{}] SAVE_NONVOL_FAR register mismatch at index {} for function at 0x{:X}", file_name, index, func_addr);
            assert_eq!(offset, exp_offset, "[{}] SAVE_NONVOL_FAR offset mismatch at index {} for function at 0x{:X}", file_name, index, func_addr);
        }
        (DecodedUnwindOp::SaveXmm128 { register, offset }, ExpectedUnwindOp::SaveXmm128 { register: exp_reg, offset: exp_offset }) => {
            let actual_name = DecodedUnwindCode::xmm_name(*register);
            assert_eq!(actual_name, exp_reg, "[{}] SAVE_XMM128 register mismatch at index {} for function at 0x{:X}", file_name, index, func_addr);
            assert_eq!(offset, exp_offset, "[{}] SAVE_XMM128 offset mismatch at index {} for function at 0x{:X}", file_name, index, func_addr);
        }
        (DecodedUnwindOp::SaveXmm128Far { register, offset }, ExpectedUnwindOp::SaveXmm128Far { register: exp_reg, offset: exp_offset }) => {
            let actual_name = DecodedUnwindCode::xmm_name(*register);
            assert_eq!(actual_name, exp_reg, "[{}] SAVE_XMM128_FAR register mismatch at index {} for function at 0x{:X}", file_name, index, func_addr);
            assert_eq!(offset, exp_offset, "[{}] SAVE_XMM128_FAR offset mismatch at index {} for function at 0x{:X}", file_name, index, func_addr);
        }
        (DecodedUnwindOp::PushMachFrame { error_code }, ExpectedUnwindOp::PushMachFrame { error_code: exp_ec }) => {
            assert_eq!(error_code, exp_ec, "[{}] PUSH_MACHFRAME error_code mismatch at index {} for function at 0x{:X}", file_name, index, func_addr);
        }
        (_, ExpectedUnwindOp::Unknown { .. }) => {
            // Unknown expected operations are OK
        }
        _ => {
            panic!(
                "[{}] Unwind operation type mismatch at index {} for function at 0x{:X}. Got {:?} expected {:?}",
                file_name, index, func_addr, actual, expected
            );
        }
    }
}

#[test]
fn unwind_info_parser_sanity_check() {
    let test_files = discover_test_files();
    assert!(!test_files.is_empty(), "No test file pairs found in {}", TEST_DIR);
    
    println!("Found {} test file pairs:", test_files.len());
    for (exe_path, txt_path, base_name) in &test_files {
        println!("  {} -> ({}, {})", base_name, exe_path.display(), txt_path.display());
    }
    
    // Verify the parser runs without errors on all txt files
    let mut total_functions = 0;
    let mut total_codes = 0;
    for (_exe_path, txt_path, base_name) in &test_files {
        let txt_content = fs::read_to_string(txt_path)
            .unwrap_or_else(|e| panic!("Failed to read {}: {:?}", txt_path.display(), e));
        
        let functions = parse_unwind_info(&txt_content);
        
        let codes_count: usize = functions.iter().map(|f| f.unwind_codes.len()).sum();
        println!("{}: Parsed {} functions with {} unwind codes", base_name, functions.len(), codes_count);
        
        total_functions += functions.len();
        total_codes += codes_count;
    }
    
    println!("\nTotal: {} functions with {} unwind codes across all files", total_functions, total_codes);
    assert!(total_codes > 0, "Expected at least some unwind codes across all test files");
}


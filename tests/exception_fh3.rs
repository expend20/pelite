/*!
Tests for FH3 (FuncInfo3) exception handling structures.

Test data files (.exe) and expected values (.txt generated by Microsoft's DUMPBIN tool)
are automatically discovered from the `tests/exceptions/` directory.
Files are matched by their base name (e.g., `foo.exe` matches `foo.txt`).

FH3 functions are identified by the magic number 0x19930522 and use the
`__CxxFrameHandler3` exception handler.
*/

mod dumpbin_parser;

use dumpbin_parser::{parse_fh3_functions, ExpectedFh3};
use pelite::pe64::{Pe, PeFile};
use pelite::pe64::exception::{HandlerType};
use pelite::pe64::exception_fh3::{FuncInfo3, UnwindInfoFh3Ext};
use pelite::FileMap;
use std::fs;
use std::path::{Path, PathBuf};

const TEST_DIR: &str = "tests/exceptions";

/// Discovers all .exe/.txt file pairs in the test directory that contain FH3 functions.
/// Returns a list of (exe_path, txt_path, base_name) tuples.
fn discover_fh3_test_files() -> Vec<(PathBuf, PathBuf, String)> {
    let test_dir = Path::new(TEST_DIR);
    let mut pairs = Vec::new();
    
    if let Ok(entries) = fs::read_dir(test_dir) {
        // Collect all .exe files
        let exe_files: Vec<PathBuf> = entries
            .filter_map(|e| e.ok())
            .map(|e| e.path())
            .filter(|p| p.extension().map_or(false, |ext| ext == "exe"))
            .collect();
        
        // For each .exe, check if matching .txt exists
        for exe_path in exe_files {
            let base_name = exe_path.file_stem()
                .and_then(|s| s.to_str())
                .map(|s| s.to_string());
            
            if let Some(base) = base_name {
                let txt_path = test_dir.join(format!("{}.txt", base));
                if txt_path.exists() {
                    // Check if txt file contains FH3 functions (Magic Number: 19930522 without FH4)
                    if let Ok(content) = fs::read_to_string(&txt_path) {
                        let has_fh3 = content.contains("Magic Number:") 
                            && content.contains("19930522")
                            && !content.contains("EH Handler Data (FH4):");
                        if has_fh3 {
                            pairs.push((exe_path, txt_path, base));
                        }
                    }
                }
            }
        }
    }
    
    pairs.sort_by(|a, b| a.2.cmp(&b.2)); // Sort by base name for consistent ordering
    pairs
}

//----------------------------------------------------------------
// Tests
//----------------------------------------------------------------

#[test]
fn fh3_basic_exception_table() {
    let test_files = discover_fh3_test_files();
    assert!(!test_files.is_empty(), "No FH3 test file pairs found in {}", TEST_DIR);
    
    for (exe_path, _txt_path, base_name) in &test_files {
        println!("Testing basic exception table for: {}", base_name);
        
        let file_map = FileMap::open(exe_path)
            .unwrap_or_else(|e| panic!("Failed to open {}: {:?}", exe_path.display(), e));
        let file = PeFile::from_bytes(&file_map)
            .unwrap_or_else(|e| panic!("Failed to parse PE {}: {:?}", exe_path.display(), e));
        let exception = file.exception()
            .unwrap_or_else(|e| panic!("Failed to get exception table for {}: {:?}", exe_path.display(), e));
        
        // Verify the table is sorted
        assert!(exception.check_sorted(), "Exception table should be sorted for {}", base_name);
        
        // Verify there are some functions
        let func_count = exception.functions().count();
        assert!(func_count > 0, "Expected at least some functions in exception table for {}", base_name);
        println!("  {} has {} functions in exception table", base_name, func_count);
    }
}

#[test]
fn fh3_parsing() {
    let test_files = discover_fh3_test_files();
    assert!(!test_files.is_empty(), "No FH3 test file pairs found in {}", TEST_DIR);
    
    let mut total_verified = 0;
    
    for (exe_path, txt_path, base_name) in &test_files {
        println!("Testing FH3 parsing for: {}", base_name);
        
        // Parse expected data from txt file
        let txt_content = fs::read_to_string(txt_path)
            .unwrap_or_else(|e| panic!("Failed to read {}: {:?}", txt_path.display(), e));
        let expected_functions = parse_fh3_functions(&txt_content);
        
        if expected_functions.is_empty() {
            println!("  No FH3 functions found in txt file, skipping");
            continue;
        }
        
        // Load the PE file
        let file_map = FileMap::open(exe_path)
            .unwrap_or_else(|e| panic!("Failed to open {}: {:?}", exe_path.display(), e));
        let file = PeFile::from_bytes(&file_map)
            .unwrap_or_else(|e| panic!("Failed to parse PE {}: {:?}", exe_path.display(), e));
        let exception = file.exception()
            .unwrap_or_else(|e| panic!("Failed to get exception table for {}: {:?}", exe_path.display(), e));
        
        // Track how many functions we've verified for this file
        let mut verified_count = 0;
        
        for expected in &expected_functions {
            // Find the function by begin address
            let func = exception
                .functions()
                .find(|f| f.image().BeginAddress == expected.begin_address)
                .unwrap_or_else(|| panic!("[{}] Function at 0x{:X} not found", base_name, expected.begin_address));
            
            let image = func.image();
            assert_eq!(
                image.BeginAddress, expected.begin_address,
                "[{}] BeginAddress mismatch for function at 0x{:X}",
                base_name, expected.begin_address
            );
            assert_eq!(
                image.EndAddress, expected.end_address,
                "[{}] EndAddress mismatch for function at 0x{:X}",
                base_name, expected.begin_address
            );
            
            // Get unwind info and parse FH3
            let unwind_info = func.unwind_info()
                .unwrap_or_else(|e| panic!("[{}] UnwindInfo failed for function at 0x{:X}: {:?}", base_name, expected.begin_address, e));
            
            // Verify handler_type() correctly identifies this as FH3
            let handler_type = unwind_info.handler_type(expected.begin_address, expected.end_address);
            assert_eq!(
                handler_type, HandlerType::Fh3,
                "[{}] handler_type() should return Fh3 for function at 0x{:X}, got {:?}",
                base_name, expected.begin_address, handler_type
            );
            
            let fh3 = unwind_info.func_info3()
                .unwrap_or_else(|e| panic!("[{}] FH3 parsing failed for function at 0x{:X}: {:?}", base_name, expected.begin_address, e));
            
            verify_fh3(&fh3, expected, base_name);
            verified_count += 1;
        }
        
        println!("  Verified {} FH3 functions in {}", verified_count, base_name);
        total_verified += verified_count;
    }
    
    println!("Total verified: {} FH3 functions across {} test files", total_verified, test_files.len());
    assert!(total_verified >= 1, "Should have verified at least 1 FH3 function total");
}

fn verify_fh3(fh3: &FuncInfo3, expected: &ExpectedFh3, file_name: &str) {
    // Verify header fields
    assert_eq!(
        fh3.magic_number, expected.magic_number,
        "[{}] Magic number mismatch for function at 0x{:X}. Got 0x{:X} expected 0x{:X}",
        file_name, expected.begin_address, fh3.magic_number, expected.magic_number
    );
    assert_eq!(
        fh3.max_state, expected.max_state,
        "[{}] Max state mismatch for function at 0x{:X}. Got {} expected {}",
        file_name, expected.begin_address, fh3.max_state, expected.max_state
    );
    assert_eq!(
        fh3.unwind_map_rva, expected.unwind_map_rva,
        "[{}] Unwind map RVA mismatch for function at 0x{:X}",
        file_name, expected.begin_address
    );
    assert_eq!(
        fh3.try_block_count, expected.try_block_count,
        "[{}] Try block count mismatch for function at 0x{:X}",
        file_name, expected.begin_address
    );
    assert_eq!(
        fh3.try_block_map_rva, expected.try_block_map_rva,
        "[{}] Try block map RVA mismatch for function at 0x{:X}",
        file_name, expected.begin_address
    );
    assert_eq!(
        fh3.ip_map_count, expected.ip_map_count,
        "[{}] IP map count mismatch for function at 0x{:X}",
        file_name, expected.begin_address
    );
    assert_eq!(
        fh3.ip_map_rva, expected.ip_map_rva,
        "[{}] IP map RVA mismatch for function at 0x{:X}",
        file_name, expected.begin_address
    );
    assert_eq!(
        fh3.frame_offset, expected.frame_offset,
        "[{}] Frame offset mismatch for function at 0x{:X}",
        file_name, expected.begin_address
    );
    assert_eq!(
        fh3.es_type_list_rva, expected.es_type_list_rva,
        "[{}] ES type list RVA mismatch for function at 0x{:X}",
        file_name, expected.begin_address
    );
    assert_eq!(
        fh3.eh_flags, expected.eh_flags,
        "[{}] EH flags mismatch for function at 0x{:X}",
        file_name, expected.begin_address
    );

    // Verify IP to State Map
    assert_eq!(
        fh3.ip_to_state_map.len(),
        expected.ip_to_state.len(),
        "[{}] IP to State Map count mismatch for function at 0x{:X}. Got {} expected {}",
        file_name, expected.begin_address,
        fh3.ip_to_state_map.len(),
        expected.ip_to_state.len()
    );
    
    for (i, (actual, (expected_ip, expected_state))) in fh3.ip_to_state_map.iter()
        .zip(&expected.ip_to_state).enumerate() 
    {
        assert_eq!(
            actual.ip_rva, *expected_ip,
            "[{}] IP RVA mismatch at index {} for function at 0x{:X}. Got 0x{:X} expected 0x{:X}",
            file_name, i, expected.begin_address, actual.ip_rva, expected_ip
        );
        assert_eq!(
            actual.state, *expected_state,
            "[{}] State mismatch at index {} for function at 0x{:X}. Got {} expected {}",
            file_name, i, expected.begin_address, actual.state, expected_state
        );
    }
    
    // Verify Unwind Map
    assert_eq!(
        fh3.unwind_map.len(),
        expected.unwind_map.len(),
        "[{}] Unwind Map count mismatch for function at 0x{:X}. Got {} expected {}",
        file_name, expected.begin_address,
        fh3.unwind_map.len(),
        expected.unwind_map.len()
    );
    
    for (i, (actual, (expected_next, expected_action))) in fh3.unwind_map.iter()
        .zip(&expected.unwind_map).enumerate() 
    {
        assert_eq!(
            actual.next_state, *expected_next,
            "[{}] Next state mismatch at state {} for function at 0x{:X}. Got {} expected {}",
            file_name, i, expected.begin_address, actual.next_state, expected_next
        );
        assert_eq!(
            actual.action_rva, *expected_action,
            "[{}] Action RVA mismatch at state {} for function at 0x{:X}. Got 0x{:X} expected 0x{:X}",
            file_name, i, expected.begin_address, actual.action_rva, expected_action
        );
    }
    
    // Verify Try Block Map
    assert_eq!(
        fh3.try_block_map.len(),
        expected.try_blocks.len(),
        "[{}] Try Block Map count mismatch for function at 0x{:X}. Got {} expected {}",
        file_name, expected.begin_address,
        fh3.try_block_map.len(),
        expected.try_blocks.len()
    );
    
    for (i, (actual, expected_try)) in fh3.try_block_map.iter()
        .zip(&expected.try_blocks).enumerate() 
    {
        assert_eq!(
            actual.try_low, expected_try.try_low,
            "[{}] try_low mismatch at try block {} for function at 0x{:X}",
            file_name, i, expected.begin_address
        );
        assert_eq!(
            actual.try_high, expected_try.try_high,
            "[{}] try_high mismatch at try block {} for function at 0x{:X}",
            file_name, i, expected.begin_address
        );
        assert_eq!(
            actual.catch_high, expected_try.catch_high,
            "[{}] catch_high mismatch at try block {} for function at 0x{:X}",
            file_name, i, expected.begin_address
        );
        
        // Verify handlers
        assert_eq!(
            actual.handlers.len(),
            expected_try.handlers.len(),
            "[{}] Handler count mismatch at try block {} for function at 0x{:X}",
            file_name, i, expected.begin_address
        );
        
        for (j, (actual_h, expected_h)) in actual.handlers.iter()
            .zip(&expected_try.handlers).enumerate() 
        {
            assert_eq!(
                actual_h.adjectives, expected_h.adjectives,
                "[{}] Handler adjectives mismatch at try block {}, handler {} for function at 0x{:X}. Got 0x{:X} expected 0x{:X}",
                file_name, i, j, expected.begin_address, actual_h.adjectives, expected_h.adjectives
            );
            assert_eq!(
                actual_h.type_desc_rva, expected_h.type_desc_rva,
                "[{}] Handler type_desc_rva mismatch at try block {}, handler {} for function at 0x{:X}. Got 0x{:X} expected 0x{:X}",
                file_name, i, j, expected.begin_address, actual_h.type_desc_rva, expected_h.type_desc_rva
            );
            assert_eq!(
                actual_h.catch_obj_offset, expected_h.catch_obj_offset,
                "[{}] Handler catch_obj_offset mismatch at try block {}, handler {} for function at 0x{:X}. Got 0x{:X} expected 0x{:X}",
                file_name, i, j, expected.begin_address, actual_h.catch_obj_offset, expected_h.catch_obj_offset
            );
            assert_eq!(
                actual_h.handler_rva, expected_h.handler_rva,
                "[{}] Handler handler_rva mismatch at try block {}, handler {} for function at 0x{:X}. Got 0x{:X} expected 0x{:X}",
                file_name, i, j, expected.begin_address, actual_h.handler_rva, expected_h.handler_rva
            );
            assert_eq!(
                actual_h.disp_frame, expected_h.disp_frame,
                "[{}] Handler disp_frame mismatch at try block {}, handler {} for function at 0x{:X}. Got 0x{:X} expected 0x{:X}",
                file_name, i, j, expected.begin_address, actual_h.disp_frame, expected_h.disp_frame
            );
        }
    }
}

#[test]
fn fh3_txt_parser_sanity_check() {
    let test_files = discover_fh3_test_files();
    assert!(!test_files.is_empty(), "No FH3 test file pairs found in {}", TEST_DIR);
    
    println!("Found {} FH3 test file pairs:", test_files.len());
    for (exe_path, txt_path, base_name) in &test_files {
        println!("  {} -> ({}, {})", base_name, exe_path.display(), txt_path.display());
    }
    
    // Verify the parser runs without errors on all txt files
    let mut total_fh3_functions = 0;
    for (_exe_path, txt_path, base_name) in &test_files {
        let txt_content = fs::read_to_string(txt_path)
            .unwrap_or_else(|e| panic!("Failed to read {}: {:?}", txt_path.display(), e));
        
        let functions = parse_fh3_functions(&txt_content);
        
        println!("\n{}: Parsed {} FH3 functions", base_name, functions.len());
        for f in &functions {
            println!("  0x{:04X}-0x{:04X}: magic=0x{:X}, max_state={}, {} ip_states, {} unwind_entries, {} try_blocks",
                f.begin_address, f.end_address,
                f.magic_number, f.max_state,
                f.ip_to_state.len(), f.unwind_map.len(), f.try_blocks.len());
        }
        total_fh3_functions += functions.len();
    }
    
    // At least some test files should have FH3 functions
    assert!(total_fh3_functions > 0,
        "Expected at least some FH3 functions across all test files, got none");
}


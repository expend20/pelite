/*!
Tests for C Structured Exception Handling (CSEH) structures.

Test data files (.exe) and expected values (.txt generated by Microsoft's DUMPBIN tool)
are automatically discovered from the `tests/exceptions/` directory.
Files are matched by their base name (e.g., `foo.exe` matches `foo.txt`).

CSEH functions are identified by the `__C_specific_handler` exception handler
and use C-style `__try`/`__except`/`__finally` blocks.
*/

mod dumpbin_parser;

use dumpbin_parser::{parse_cseh_functions, ExpectedCseh};
use pelite::pe64::{Pe, PeFile};
use pelite::pe64::exception::{HandlerType};
use pelite::pe64::exception_cseh::{CScopeTable, UnwindInfoCsehExt};
use pelite::FileMap;
use std::fs;
use std::path::{Path, PathBuf};

const TEST_DIR: &str = "tests/exceptions";

/// Discovers all .exe/.txt file pairs in the test directory that contain CSEH functions.
/// Returns a list of (exe_path, txt_path, base_name) tuples.
fn discover_cseh_test_files() -> Vec<(PathBuf, PathBuf, String)> {
    let test_dir = Path::new(TEST_DIR);
    let mut pairs = Vec::new();
    
    if let Ok(entries) = fs::read_dir(test_dir) {
        // Collect all .exe files
        let exe_files: Vec<PathBuf> = entries
            .filter_map(|e| e.ok())
            .map(|e| e.path())
            .filter(|p| p.extension().map_or(false, |ext| ext == "exe"))
            .collect();
        
        // For each .exe, check if matching .txt exists
        for exe_path in exe_files {
            let base_name = exe_path.file_stem()
                .and_then(|s| s.to_str())
                .map(|s| s.to_string());
            
            if let Some(base) = base_name {
                let txt_path = test_dir.join(format!("{}.txt", base));
                if txt_path.exists() {
                    // Check if txt file contains __C_specific_handler functions
                    if let Ok(content) = fs::read_to_string(&txt_path) {
                        if content.contains("__C_specific_handler") {
                            pairs.push((exe_path, txt_path, base));
                        }
                    }
                }
            }
        }
    }
    
    pairs.sort_by(|a, b| a.2.cmp(&b.2)); // Sort by base name for consistent ordering
    pairs
}

//----------------------------------------------------------------
// Tests
//----------------------------------------------------------------

#[test]
fn cseh_basic_exception_table() {
    let test_files = discover_cseh_test_files();
    assert!(!test_files.is_empty(), "No CSEH test file pairs found in {}", TEST_DIR);
    
    for (exe_path, _txt_path, base_name) in &test_files {
        println!("Testing basic exception table for: {}", base_name);
        
        let file_map = FileMap::open(exe_path)
            .unwrap_or_else(|e| panic!("Failed to open {}: {:?}", exe_path.display(), e));
        let file = PeFile::from_bytes(&file_map)
            .unwrap_or_else(|e| panic!("Failed to parse PE {}: {:?}", exe_path.display(), e));
        let exception = file.exception()
            .unwrap_or_else(|e| panic!("Failed to get exception table for {}: {:?}", exe_path.display(), e));
        
        // Verify the table is sorted
        assert!(exception.check_sorted(), "Exception table should be sorted for {}", base_name);
        
        // Verify there are some functions
        let func_count = exception.functions().count();
        assert!(func_count > 0, "Expected at least some functions in exception table for {}", base_name);
        println!("  {} has {} functions in exception table", base_name, func_count);
    }
}

#[test]
fn cseh_parsing() {
    let test_files = discover_cseh_test_files();
    assert!(!test_files.is_empty(), "No CSEH test file pairs found in {}", TEST_DIR);
    
    let mut total_verified = 0;
    
    for (exe_path, txt_path, base_name) in &test_files {
        println!("Testing CSEH parsing for: {}", base_name);
        
        // Parse expected data from txt file
        let txt_content = fs::read_to_string(txt_path)
            .unwrap_or_else(|e| panic!("Failed to read {}: {:?}", txt_path.display(), e));
        let expected_functions = parse_cseh_functions(&txt_content);
        
        if expected_functions.is_empty() {
            println!("  No CSEH functions found in txt file, skipping");
            continue;
        }
        
        // Load the PE file
        let file_map = FileMap::open(exe_path)
            .unwrap_or_else(|e| panic!("Failed to open {}: {:?}", exe_path.display(), e));
        let file = PeFile::from_bytes(&file_map)
            .unwrap_or_else(|e| panic!("Failed to parse PE {}: {:?}", exe_path.display(), e));
        let exception = file.exception()
            .unwrap_or_else(|e| panic!("Failed to get exception table for {}: {:?}", exe_path.display(), e));
        
        // Track how many functions we've verified for this file
        let mut verified_count = 0;
        
        for expected in &expected_functions {
            // Find the function by begin address
            let func = exception
                .functions()
                .find(|f| f.image().BeginAddress == expected.begin_address)
                .unwrap_or_else(|| panic!("[{}] Function at 0x{:X} not found", base_name, expected.begin_address));
            
            let image = func.image();
            assert_eq!(
                image.BeginAddress, expected.begin_address,
                "[{}] BeginAddress mismatch for function at 0x{:X}",
                base_name, expected.begin_address
            );
            assert_eq!(
                image.EndAddress, expected.end_address,
                "[{}] EndAddress mismatch for function at 0x{:X}",
                base_name, expected.begin_address
            );
            
            // Get unwind info and parse C scope table
            let unwind_info = func.unwind_info()
                .unwrap_or_else(|e| panic!("[{}] UnwindInfo failed for function at 0x{:X}: {:?}", base_name, expected.begin_address, e));
            
            // Verify handler_type() correctly identifies this as CSEH
            let handler_type = unwind_info.handler_type(expected.begin_address, expected.end_address);
            assert_eq!(
                handler_type, HandlerType::Cseh,
                "[{}] handler_type() should return Cseh for function at 0x{:X}, got {:?}",
                base_name, expected.begin_address, handler_type
            );
            
            let scope_table = unwind_info.c_scope_table()
                .unwrap_or_else(|e| panic!("[{}] C Scope Table parsing failed for function at 0x{:X}: {:?}", base_name, expected.begin_address, e));
            
            verify_cseh(&scope_table, expected, base_name);
            verified_count += 1;
        }
        
        println!("  Verified {} CSEH functions in {}", verified_count, base_name);
        total_verified += verified_count;
    }
    
    println!("Total verified: {} CSEH functions across {} test files", total_verified, test_files.len());
    assert!(total_verified >= 1, "Should have verified at least 1 CSEH function total");
}

fn verify_cseh(scope_table: &CScopeTable, expected: &ExpectedCseh, file_name: &str) {
    // Verify scope table count
    assert_eq!(
        scope_table.count as usize,
        expected.scope_table.len(),
        "[{}] Scope table count mismatch for function at 0x{:X}. Got {} expected {}",
        file_name, expected.begin_address,
        scope_table.count,
        expected.scope_table.len()
    );
    assert_eq!(
        scope_table.entries.len(),
        expected.scope_table.len(),
        "[{}] Scope table entries count mismatch for function at 0x{:X}. Got {} expected {}",
        file_name, expected.begin_address,
        scope_table.entries.len(),
        expected.scope_table.len()
    );
    
    // Verify each scope entry
    for (i, (actual, expected_entry)) in scope_table.entries.iter()
        .zip(&expected.scope_table).enumerate() 
    {
        assert_eq!(
            actual.begin_address, expected_entry.begin_address,
            "[{}] BeginAddress mismatch at scope entry {} for function at 0x{:X}. Got 0x{:X} expected 0x{:X}",
            file_name, i, expected.begin_address, actual.begin_address, expected_entry.begin_address
        );
        assert_eq!(
            actual.end_address, expected_entry.end_address,
            "[{}] EndAddress mismatch at scope entry {} for function at 0x{:X}. Got 0x{:X} expected 0x{:X}",
            file_name, i, expected.begin_address, actual.end_address, expected_entry.end_address
        );
        assert_eq!(
            actual.handler_address, expected_entry.handler_address,
            "[{}] HandlerAddress mismatch at scope entry {} for function at 0x{:X}. Got 0x{:X} expected 0x{:X}",
            file_name, i, expected.begin_address, actual.handler_address, expected_entry.handler_address
        );
        assert_eq!(
            actual.jump_target, expected_entry.jump_target,
            "[{}] JumpTarget mismatch at scope entry {} for function at 0x{:X}. Got 0x{:X} expected 0x{:X}",
            file_name, i, expected.begin_address, actual.jump_target, expected_entry.jump_target
        );
        
        // Verify the is_finally/is_except helpers work correctly
        if expected_entry.jump_target == 0 {
            assert!(actual.is_finally(), 
                "[{}] Entry {} should be a __finally handler (jump_target=0)",
                file_name, i);
            assert!(!actual.is_except(),
                "[{}] Entry {} should not be an __except handler (jump_target=0)",
                file_name, i);
        } else {
            assert!(actual.is_except(),
                "[{}] Entry {} should be an __except handler (jump_target!=0)",
                file_name, i);
            assert!(!actual.is_finally(),
                "[{}] Entry {} should not be a __finally handler (jump_target!=0)",
                file_name, i);
        }
    }
}

#[test]
fn cseh_txt_parser_sanity_check() {
    let test_files = discover_cseh_test_files();
    assert!(!test_files.is_empty(), "No CSEH test file pairs found in {}", TEST_DIR);
    
    println!("Found {} CSEH test file pairs:", test_files.len());
    for (exe_path, txt_path, base_name) in &test_files {
        println!("  {} -> ({}, {})", base_name, exe_path.display(), txt_path.display());
    }
    
    // Verify the parser runs without errors on all txt files
    let mut total_cseh_functions = 0;
    for (_exe_path, txt_path, base_name) in &test_files {
        let txt_content = fs::read_to_string(txt_path)
            .unwrap_or_else(|e| panic!("Failed to read {}: {:?}", txt_path.display(), e));
        
        let functions = parse_cseh_functions(&txt_content);
        
        println!("\n{}: Parsed {} CSEH functions", base_name, functions.len());
        for f in &functions {
            println!("  0x{:04X}-0x{:04X}: {} scope entries",
                f.begin_address, f.end_address, f.scope_table.len());
            for (i, entry) in f.scope_table.iter().enumerate() {
                let kind = if entry.jump_target == 0 { "__finally" } else { "__except" };
                println!("    [{}] {} Begin=0x{:04X} End=0x{:04X} Handler=0x{:04X} Target=0x{:04X}",
                    i, kind, entry.begin_address, entry.end_address, 
                    entry.handler_address, entry.jump_target);
            }
        }
        total_cseh_functions += functions.len();
    }
    
    // At least some test files should have CSEH functions
    assert!(total_cseh_functions > 0,
        "Expected at least some CSEH functions across all test files, got none");
}



